# Antoshka - Система управления заказами и складом

- [INSTALL_PROJECT.md](INSTALL_PROJECT.md) - Запуск проекта

---

## ВЕБ-ИНТЕРФЕЙС (Web UI)

### Главная страница
- **Функционал**: Автоматический редирект на `/orders`

### `/orders` - Список заказов
- **Функционал**:
    - Просмотр всех заказов с пагинацией (5 на страницу)
    - Фильтрация по статусу (pending, reserved, awaiting_restock, failed)
    - Поиск по SKU
    - Цветовые бейджи статусов
- **Действия**:
    - Клик на заказ → переход к деталям
    - Кнопка "Создать заказ" → переход к форме создания

### `/orders/create` - Создание заказа
- **Функционал**:
    - Форма с полями: SKU (артикул) и Qty (количество)
    - Валидация на фронтенде (SKU >= 1, qty >= 1)
    - AJAX отправка через API (`POST /api/order`)
    - После создания заказа отображается:
        - Блок визуализации процесса обработки с этапами: 
        1. создание заказа, 
        2. обработка события, 
        3. резервирование товара, 
        4. запрос к поставщику
        5. Текущий статус заказа (ID и статус) с обновлением в реальном времени
        - Логи процесса обработки в реальном времени
- **Действия**:
    - Заполнить форму → Отправить → Заказ создается со статусом `pending`
    - После создания автоматически запускается процесс резервирования:
        1. Вызывается `OrderCreated::dispatch($order)` - событие попадает в очередь (асинхронно)
        2. Воркер очереди обрабатывает событие и вызывает метод `handle()` в `OrderCreated`
        3. Метод `handle()` запускает `ReserveInventoryJob::dispatch($order->id)`
        4. Джоба проверяет наличие товара и резервирует его (или запрашивает у поставщика)

### `/orders/{id}` - Детали заказа
- **Функционал**:
    - Полная информация о заказе (ID, SKU, количество, статус, даты)
    - История движений склада для этого заказа
- **Детали**:
    - Цветовые бейджи статусов заказа
    - Даты отображаются в формате `дд.мм.гггг чч:мм:сс`
    - Кнопка "Назад к списку" для быстрой навигации
    - История движений с цветовыми бейджами типов (резервирование, освобождение, пополнение)
    - Если движений нет, отображается сообщение "Движений по этому заказу пока нет"
    - `supplier_check_attempts` отображается в формате "X / 2" (максимум 2 попытки)

### `/inventory` - Список товаров на складе
- **Функционал**:
    - Таблица всех товаров (SKU, доступное количество, зарезервированное количество)
    - Поиск по SKU
    - Сортировка по SKU, available_qty, reserved_qty
    - Пагинация (5 на страницу)
- **Действия**:
    - Клик на кнопку просмотра в действиях → переход к истории движений
- **Детали**:
    - Отображается колонки "Доступно" "Зарезервированно" "Всего"
    - Кнопка "Сбросить" появляется при активном поиске
    - Кнопка просмотра истории движений (иконка глаза) для каждого товара
    - При отсутствии результатов поиска отображается сообщение "Товары не найдены"

### `/inventory/{sku}/movements` - История движений по товару
- **Функционал**:
    - Таблица всех движений для конкретного SKU
    - Фильтрация по типу движения (reserve, release, restock)
    - Фильтрация по дате (от/до)
    - Отображение: тип, количество, количество до/после, связанный заказ, дата
    - Пагинация (5 на страницу)
- **Детали**:
    - Блок "Текущее состояние" с карточками: Доступно, Зарезервировано, Всего
    - Кликабельные ссылки на заказы в колонке "Заказ" (переход к деталям заказа)
    - Кнопка "Сбросить" для сброса всех фильтров
    - Цветовые бейджи типов движений (резервирование, освобождение, пополнение)
    - Даты отображаются в формате `дд.мм.гггг чч:мм:сс`
    - При отсутствии движений отображается сообщение "Движений пока нет"

### `/dashboard` - Дашборд
- **Функционал**:
    - Статистика по заказам (по статусам)
    - Быстрые действия (создать заказ, просмотр склада)
    - Список последних заказов
- **Детали**:
    - 4 карточки статистики: Всего заказов, Ожидают (pending), Зарезервировано (reserved), Товаров на складе
    - Секция "Быстрые действия" с 3 ссылками: Создать заказ, Просмотр заказов, Просмотр склада
    - Секция "Последние заказы" показывает 5 последних заказов с кликабельными ссылками, SKU, количеством и цветовым бейджем статуса
    - При отсутствии заказов отображается сообщение "Заказов пока нет"

---

## КАК РАБОТАЕТ СИСТЕМА

### Процесс создания и резервирования заказа

1. **Создание заказа** (`POST /api/order`)
    - Пользователь создает заказ через веб-форму или API
    - Заказ сохраняется со статусом `pending`
    - Вызывается `OrderCreated::dispatch($order)` - событие попадает в очередь (асинхронно)
    - Контроллер сразу возвращает JSON ответ, не дожидаясь обработки события

2. **Автоматическое резервирование** (асинхронно через очередь)
    - Воркер очереди обрабатывает событие `OrderCreated`
    - Вызывается метод `handle()` в самом событии `OrderCreated`
    - Метод `handle()` логирует начало резервирования и запускает `ReserveInventoryJob::dispatch($order->id)`
    - Запускается `ReserveInventoryJob`
    - Проверяется наличие товара на складе:
        - **Если достаточно** → товар резервируется, статус → `reserved`
        - **Если недостаточно** → статус → `awaiting_restock`, запускается запрос к поставщику

3. **Запрос к поставщику** (если недостаточно товара)
    - Запускается `RequestSupplierReservationJob`
    - Отправляется запрос к `/api/supplier/reserve`
    - Если принято → сохраняется `supplier_ref`, запускается проверка статуса через 15 секунд
    - Если отклонено → статус → `failed`

4. **Проверка статуса поставки**
    - Запускается `CheckSupplierStatusJob` через 15 секунд после получения `supplier_ref`
    - Отправляется запрос к `/api/supplier/status/{ref}`
    - **Статус "ok"** → товар пополняется и резервируется, статус → `reserved`
    - **Статус "fail"** → статус → `failed`
    - **Статус "delayed"** → увеличивается счетчик попыток, повторная проверка через 15 секунд (максимум 2 попытки)
    - **Примечание**: На странице создания заказа (`/orders/create`) статус заказа проверяется каждую секунду через API для обновления визуализации процесса обработки

### Статусы заказа

- **`pending`** - Заказ создан, ожидает резервирования
- **`reserved`** - Товар успешно зарезервирован
- **`awaiting_restock`** - Недостаточно товара, ожидается пополнение от поставщика
- **`failed`** - Резервирование не удалось (отклонено поставщиком или превышен лимит попыток)

### Типы движений склада

- **`reserve`** - Резервирование товара (available_qty уменьшается, reserved_qty увеличивается)
- **`release`** - Освобождение резерва (available_qty увеличивается, reserved_qty уменьшается)
- **`restock`** - Пополнение склада от поставщика (available_qty увеличивается)

---

## МОНИТОРИНГ И ЛОГИ

### Логи приложения
- **`storage/logs/laravel.log`** - Основной лог (все логи приложения записываются сюда)

### Что логируется
- **Ошибки при создании заказов** (Log::error в OrderService)
- **Резервирование товаров** (Log::info при успешном резервировании, Log::info при недостатке товара)
- **Запросы к поставщику** (Log::info при принятии/отклонении запроса, Log::error при ошибках)
- **Проверка статуса поставки** (Log::info при изменении статуса, Log::error при ошибках)
- **Ошибки резервирования** (Log::error в ReserveInventoryJob)
- **Ошибки интеграции с поставщиком** (Log::error в SupplierService, RequestSupplierReservationJob, CheckSupplierStatusJob)
- **Ошибки выполнения Jobs** (Log::error в методах failed() всех Jobs)

---

### Unit тесты

#### `tests/Unit/OrderTest.php` - Тесты модели Order
**Что проверяет:**
- Создание заказа с корректными данными
- Константы статусов заказа (pending, reserved, awaiting_restock, failed)
- Query scopes для фильтрации по статусам (pending, reserved, awaitingRestock, failed)

**Польза:** Гарантирует корректность работы модели Order, правильность констант статусов и работу scope-методов для выборки заказов по статусам.

#### `tests/Unit/InventoryTest.php` - Тесты модели Inventory
**Что проверяет:**
- Метод `reserve()` - уменьшает available_qty и увеличивает reserved_qty при достаточном количестве
- Метод `reserve()` - возвращает false и не изменяет данные при недостаточном количестве
- Метод `release()` - увеличивает available_qty и уменьшает reserved_qty
- Метод `hasEnough()` - корректно определяет достаточность товара
- Метод `getTotalQty()` - возвращает сумму available_qty и reserved_qty

**Польза:** Обеспечивает корректность логики резервирования и освобождения товара, предотвращает ошибки в расчетах количества товара на складе.

#### `tests/Unit/SupplierServiceTest.php` - Тесты сервиса поставщика
**Что проверяет:**
- `requestReservation()` - успешный запрос резервирования (возвращает accepted=true и ref)
- `requestReservation()` - отклоненный запрос (выбрасывает SupplierException)
- `checkStatus()` - проверка статуса "ok"
- `checkStatus()` - проверка статуса "fail"
- `checkStatus()` - проверка статуса "delayed"
- Обработка сетевых ошибок (HTTP 500) при запросе резервирования

**Польза:** Проверяет корректность работы с API поставщика, обработку всех возможных ответов и ошибок сети, что критично для надежности интеграции.

#### `tests/Unit/StoreOrderRequestTest.php` - Тесты валидации
**Что проверяет:**
- Валидация проходит при корректных данных (sku и qty)
- SKU обязателен для заполнения
- SKU должен быть строкой
- SKU не должен превышать максимальную длину (255 символов)
- Qty обязателен для заполнения
- Qty должен быть целым числом
- Qty должен быть минимум 1 (не допускается 0 или отрицательные значения)

**Польза:** Гарантирует, что валидация входных данных работает корректно, предотвращает создание заказов с некорректными данными.

---

### Feature тесты

#### `tests/Feature/OrderApiTest.php` - Тесты API заказов
**Что проверяет:**
- `POST /api/order` - успешное создание заказа (статус 201, корректная структура JSON, событие OrderCreated диспатчится)
- `POST /api/order` - валидация: ошибка при пустом SKU (статус 422)
- `POST /api/order` - валидация: ошибка при некорректном qty (статус 422)
- `GET /api/orders/{id}` - получение существующего заказа (статус 200, корректные данные)
- `GET /api/orders/{id}` - получение несуществующего заказа (статус 404)

**Польза:** Проверяет корректность работы API эндпоинтов для заказов, валидацию входных данных и обработку ошибок, что критично для интеграции с внешними системами.

#### `tests/Feature/InventoryApiTest.php` - Тесты API склада
**Что проверяет:**
- `GET /api/inventory/{sku}/movements` - получение истории движений (статус 200, корректная структура JSON с несколькими движениями)
- `GET /api/inventory/{sku}/movements` - возврат пустого массива для несуществующего SKU (статус 200)

**Польза:** Гарантирует корректность работы API для получения истории движений склада, что важно для аудита и отслеживания изменений.

#### `tests/Feature/ReservationFlowTest.php` - Тесты процесса резервирования
**Что проверяет:**
- Успешный процесс резервирования: при достаточном количестве товара заказ переходит в статус "reserved", количество корректно обновляется, создается запись движения
- Процесс при недостаточном количестве: заказ переходит в статус "awaiting_restock", запускается RequestSupplierReservationJob

**Польза:** Проверяет ключевую бизнес-логику системы - процесс резервирования товара, что является основным функционалом приложения.

#### `tests/Feature/SupplierIntegrationTest.php` - Тесты интеграции с поставщиком
**Что проверяет:**
- Успешная доставка от поставщика (статус "ok"): заказ переходит в "reserved", товар пополняется и резервируется
- Отказ поставщика (статус "fail"): заказ переходит в "failed"
- Задержка поставки (статус "delayed"): увеличивается счетчик попыток, при повторной проверке с "ok" заказ резервируется
- Превышение лимита попыток при задержке: после 2 попыток заказ переходит в "failed"

**Польза:** Проверяет полный цикл интеграции с поставщиком, включая обработку всех возможных статусов и логику повторных попыток, что критично для надежности системы.

#### `tests/Feature/FullFlowTest.php` - Тесты полного потока
**Что проверяет:**
- Полный поток от создания заказа до резервирования: создание через API → обработка ReserveInventoryJob → успешное резервирование
- Полный поток от создания заказа до запроса поставщику: создание через API → обработка ReserveInventoryJob → переход в "awaiting_restock" → запуск RequestSupplierReservationJob

**Польза:** Проверяет интеграцию всех компонентов системы в реальных сценариях использования, что важно для уверенности в работоспособности системы в целом.

#### `tests/Feature/SupplierErrorHandlingTest.php` - Тесты обработки ошибок
**Что проверяет:**
- Обработка таймаута при запросе к поставщику: заказ переходит в "failed"
- Обработка сетевой ошибки при запросе к поставщику: выбрасывается SupplierException, заказ переходит в "failed"
- Обработка некорректного ответа от поставщика при проверке статуса: заказ не переходит в "reserved"

**Польза:** Гарантирует корректную обработку ошибок при работе с поставщиком, что критично для стабильности системы в условиях сетевых проблем или сбоев внешнего API.

---

## Структура проекта

### Модели (`app/Models/`)
- **Order** - модель заказа (статусы: pending, reserved, awaiting_restock, failed)
- **Inventory** - модель склада (available_qty, reserved_qty, методы: reserve, release, hasEnough, getTotalQty)
- **InventoryMovement** - модель движения товара (reserve, release, restock)

### Контроллеры (`app/Http/Controllers/`)
**Web контроллеры:**
- **OrderController** - управление заказами через веб-интерфейс (index, create, store, show)
- **InventoryController** - управление складом через веб-интерфейс (index, movements)
- **DashboardController** - дашборд с статистикой
- **SupplierController** - эмуляция API поставщика для тестирования (`/api/supplier/reserve`, `/api/supplier/status/{ref}`)

**API контроллеры (`app/Http/Controllers/Api/`):**
- **OrderController** - REST API для заказов (`POST /api/order`, `GET /api/orders/{id}`)
- **InventoryController** - REST API для склада (`GET /api/inventory/{sku}/movements`)

### Jobs (`app/Jobs/`)
- **ReserveInventoryJob** - резервирование товара на складе (3 попытки, таймаут 90 сек)
- **RequestSupplierReservationJob** - запрос резервирования у поставщика (3 попытки, таймаут 90 сек)
- **CheckSupplierStatusJob** - проверка статуса поставки от поставщика (1 попытка, собственная логика повторов, таймаут 90 сек)

### События (`app/Events/`)
- **OrderCreated** - событие создания заказа (с явной обработкой через метод `handle()`, который запускает `ReserveInventoryJob`)

### Сервисы (`app/Services/`)
- **OrderService** - бизнес-логика работы с заказами (создание, получение, форматирование, фильтрация)
- **InventoryService** - бизнес-логика работы со складом (список товаров, история движений, фильтрация и сортировка)
- **SupplierService** - интеграция с API поставщика (requestReservation, checkStatus, обработка ошибок)
- **SupplierApiService** - эмуляция API поставщика для тестирования (создание резервации, проверка статуса)
- **DashboardService** - получение данных для дашборда (статистика заказов, последние заказы)

### Исключения (`app/Exceptions/`)
- **SupplierException** - ошибки при работе с поставщиком (таймауты, сетевые ошибки, некорректные ответы)
- **InsufficientInventoryException** - недостаточно товара на складе
- **OrderNotFoundException** - заказ не найден

---

## Конфигурация

### Очереди (`config/queue.php`)
- **Поддерживаемые драйверы**: sync, database, redis, beanstalkd, sqs
- **По умолчанию**: `sync` (изменяется через `QUEUE_CONNECTION` в `.env`)
- **Рекомендуется для production**: `redis` (настроен в Docker)
- **Retry after**: 90 секунд для database и redis
- **Failed jobs**: хранятся в таблице `failed_jobs` (драйвер: database-uuids)

### Логирование (`config/logging.php`)
- **Основной канал**: `stack` → `single` → `storage/logs/laravel.log` (все логи записываются сюда)
- **Дополнительные каналы** (настроены, но не используются в коде):
  - `queue` → `storage/logs/queue.log`
  - `api` → `storage/logs/api.log`
  - `supplier` → `storage/logs/supplier.log`

### Сервисы (`config/services.php`)
- **supplier**: конфигурация API поставщика
  - `url` - URL API поставщика (из переменной окружения `SUPPLIER_API_URL`, по умолчанию `http://localhost/api/supplier`)

---

## Примечания

### Блокировки (Pessimistic Locking)

Все критические операции используют **pessimistic locking** (`lockForUpdate()`) для предотвращения race conditions:

- **Inventory::reserve()** - блокирует запись Inventory перед проверкой наличия и резервированием товара
- **Inventory::release()** - блокирует запись Inventory перед освобождением резерва
- **ReserveInventoryJob** - блокирует запись Order перед проверкой статуса и обновлением
- **RequestSupplierReservationJob** - блокирует запись Order перед сохранением `supplier_ref`

Блокировки выполняются внутри транзакций (`DB::transaction()`), что гарантирует атомарность операций и предотвращает ситуации, когда несколько процессов одновременно изменяют одни и те же данные.

### Retry логика Jobs

- **ReserveInventoryJob**: `$tries = 3` - 3 попытки при ошибке выполнения
- **RequestSupplierReservationJob**: `$tries = 3` - 3 попытки при ошибке выполнения
- **CheckSupplierStatusJob**: `$tries = 1` - 1 попытка, но есть собственная логика повторов через поле `supplier_check_attempts` в модели Order

### Таймауты Jobs

Все Jobs имеют одинаковый таймаут: **`$timeout = 90` секунд**. Если Job выполняется дольше 90 секунд, он будет прерван и помечен как failed.

### Проверка статуса поставщика

- **Максимальное количество попыток**: 2 (проверяется через `supplier_check_attempts >= 2`)
- **Задержка между проверками**: 15 секунд (используется `delay(15)` при повторной отправке `CheckSupplierStatusJob`)
- **Логика повторов**: 
  - При статусе "delayed" увеличивается `supplier_check_attempts` и через 15 секунд запускается новая проверка
  - При достижении лимита (2 попытки) заказ переходит в статус "failed"
  - При ошибке сети также увеличивается счетчик попыток

### Обработка ошибок

- Все Jobs имеют метод `failed()` для логирования критических ошибок
- При ошибках интеграции с поставщиком выбрасывается `SupplierException`
- При недостатке товара выбрасывается `InsufficientInventoryException`
- При отсутствии заказа выбрасывается `OrderNotFoundException`

